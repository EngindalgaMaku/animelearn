{
  "metadata": {
    "exportDate": "2025-08-11T22:15:18.685Z",
    "source": "code-arena-export",
    "totalRecords": 16,
    "tables": {
      "codeArenas": 16,
      "codeArenaProgress": 0,
      "codeSubmissions": 0
    }
  },
  "data": {
    "codeArenas": [
      {
        "id": "cme68u4170000wc7ons2rz4r3",
        "title": "Bubble Sort Visualizer",
        "slug": "bubble-sort-visualizer",
        "description": "Understand how bubble sort works through step-by-step visualization and learn its O(n²) time complexity",
        "content": "# Bubble Sort Algorithm\n\nBubble Sort is one of the simplest sorting algorithms to understand. It repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.\n\n## How it Works:\n1. Compare adjacent elements\n2. Swap if they're in wrong order  \n3. Continue until no swaps needed\n4. Largest element \"bubbles up\" to end\n\n## Time Complexity: O(n²)\n## Space Complexity: O(1)\n\nPerfect for learning algorithm fundamentals!",
        "difficulty": 1,
        "order": 1,
        "duration": 15,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Implement Bubble Sort\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # TODO: Implement bubble sort algorithm\n    # Hint: Use nested loops to compare adjacent elements\n    \n    return arr\n\n# Test your implementation\ntest_array = [64, 34, 25, 12, 22, 11, 90]\nprint(\"Original array:\", test_array)\nresult = bubble_sort(test_array.copy())\nprint(\"Sorted array:\", result)",
        "solutionCode": "def bubble_sort(arr):\n    n = len(arr)\n    \n    # Traverse through all array elements\n    for i in range(n):\n        # Flag to optimize - if no swapping occurs, array is sorted\n        swapped = False\n        \n        # Last i elements are already in place\n        for j in range(0, n - i - 1):\n            # Traverse the array from 0 to n-i-1\n            # Swap if the element found is greater than the next element\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        \n        # If no swapping occurred, array is sorted\n        if not swapped:\n            break\n    \n    return arr",
        "testCases": "[{\"input\":[[64,34,25,12,22,11,90]],\"expected\":[11,12,22,25,34,64,90]},{\"input\":[[5,2,8,1,9]],\"expected\":[1,2,5,8,9]},{\"input\":[[1]],\"expected\":[1]},{\"input\":[[]],\"expected\":[]}]",
        "hints": null,
        "prerequisites": null,
        "diamondReward": 40,
        "experienceReward": 80,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:41.707Z",
        "updatedAt": "2025-08-10T22:16:41.707Z",
        "examples": null,
        "learningObjectives": "[\"Understand bubble sort algorithm\",\"Learn O(n²) time complexity\",\"Practice nested loop patterns\",\"Implement swapping logic\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Algorithm Viz\",\"Sorting\",\"Beginner\"]"
      },
      {
        "id": "cme68u46w0001wc7o7arpxuhp",
        "title": "Quick Sort Master",
        "slug": "quick-sort-master",
        "description": "Master the divide-and-conquer approach with QuickSort and understand its O(n log n) average complexity",
        "content": "# Quick Sort Algorithm\n\nQuick Sort is a highly efficient sorting algorithm using divide-and-conquer strategy. It picks a 'pivot' element and partitions the array around it.\n\n## How it Works:\n1. Choose a pivot element\n2. Partition array: smaller elements left, larger right\n3. Recursively sort sub-arrays\n4. Combine results\n\n## Time Complexity: \n- Average: O(n log n)\n- Worst: O(n²)\n- Best: O(n log n)\n\n## Space Complexity: O(log n)\n\nOne of the most widely used sorting algorithms!",
        "difficulty": 3,
        "order": 2,
        "duration": 25,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Implement Quick Sort\ndef quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # TODO: Find partition index\n        # TODO: Recursively sort elements before and after partition\n        pass\n    \n    return arr\n\ndef partition(arr, low, high):\n    # TODO: Implement partitioning logic\n    # Choose pivot (last element)\n    # Rearrange array so smaller elements are on left\n    pass\n\n# Test your implementation\ntest_array = [10, 7, 8, 9, 1, 5]\nprint(\"Original array:\", test_array)\nresult = quick_sort(test_array.copy())\nprint(\"Sorted array:\", result)",
        "solutionCode": "def quick_sort(arr, low=0, high=None):\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition index\n        pi = partition(arr, low, high)\n        \n        # Recursively sort elements before and after partition\n        quick_sort(arr, low, pi - 1)\n        quick_sort(arr, pi + 1, high)\n    \n    return arr\n\ndef partition(arr, low, high):\n    # Choose the rightmost element as pivot\n    pivot = arr[high]\n    \n    # Index of smaller element (indicates right position of pivot)\n    i = low - 1\n    \n    for j in range(low, high):\n        # If current element is smaller than or equal to pivot\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Place pivot in correct position\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1",
        "testCases": "[{\"input\":[[10,7,8,9,1,5]],\"expected\":[1,5,7,8,9,10]},{\"input\":[[64,34,25,12,22,11,90]],\"expected\":[11,12,22,25,34,64,90]},{\"input\":[[3,1,4,1,5,9,2,6]],\"expected\":[1,1,2,3,4,5,6,9]}]",
        "hints": null,
        "prerequisites": null,
        "diamondReward": 60,
        "experienceReward": 120,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:41.912Z",
        "updatedAt": "2025-08-10T22:16:41.912Z",
        "examples": null,
        "learningObjectives": "[\"Master divide-and-conquer strategy\",\"Understand partitioning logic\",\"Learn recursion in algorithms\",\"Analyze time complexity trade-offs\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Algorithm Viz\",\"Sorting\",\"Divide & Conquer\",\"Advanced\"]"
      },
      {
        "id": "cme68u49q0002wc7o6xyfp5jh",
        "title": "Merge Sort Visualizer",
        "slug": "merge-sort-visualizer",
        "description": "Learn the stable O(n log n) sorting algorithm through visual divide-and-conquer demonstration",
        "content": "# Merge Sort Algorithm\n\nMerge Sort is a stable, divide-and-conquer algorithm that consistently performs in O(n log n) time regardless of input.\n\n## How it Works:\n1. Divide array into halves\n2. Recursively sort both halves\n3. Merge sorted halves back together\n4. Maintain sorted order during merge\n\n## Time Complexity: O(n log n) - Always!\n## Space Complexity: O(n)\n\nPerfect for large datasets and when stability is required!",
        "difficulty": 3,
        "order": 3,
        "duration": 20,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Implement Merge Sort\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # TODO: Divide array into halves\n    # TODO: Recursively sort both halves\n    # TODO: Merge sorted halves\n    \n    return arr\n\ndef merge(left, right):\n    # TODO: Merge two sorted arrays\n    result = []\n    i = j = 0\n    \n    # Compare elements and merge\n    \n    return result\n\n# Test your implementation\ntest_array = [38, 27, 43, 3, 9, 82, 10]\nprint(\"Original array:\", test_array)\nresult = merge_sort(test_array.copy())\nprint(\"Sorted array:\", result)",
        "solutionCode": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Divide array into halves\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    # Merge sorted halves\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    # Compare elements from both arrays and merge in order\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Add remaining elements\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result",
        "testCases": null,
        "hints": null,
        "prerequisites": null,
        "diamondReward": 55,
        "experienceReward": 110,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:42.014Z",
        "updatedAt": "2025-08-10T22:16:42.014Z",
        "examples": null,
        "learningObjectives": "[\"Understand stable sorting\",\"Master divide-and-conquer\",\"Learn array merging techniques\",\"Analyze space-time trade-offs\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Algorithm Viz\",\"Sorting\",\"Stable Sort\",\"Advanced\"]"
      },
      {
        "id": "cme68u4gb0003wc7o6ro47ydq",
        "title": "Binary Search Master",
        "slug": "binary-search-master",
        "description": "Master the O(log n) search algorithm and understand logarithmic time complexity through visualization",
        "content": "# Binary Search Algorithm\n\nBinary Search is an efficient search algorithm for sorted arrays, achieving O(log n) time complexity.\n\n## How it Works:\n1. Start with middle element\n2. If target equals middle, found!\n3. If target < middle, search left half\n4. If target > middle, search right half\n5. Repeat until found or exhausted\n\n## Time Complexity: O(log n)\n## Space Complexity: O(1)\n\nEssential algorithm for efficient searching!",
        "difficulty": 2,
        "order": 4,
        "duration": 15,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Implement Binary Search\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        # TODO: Calculate middle index\n        # TODO: Compare middle element with target\n        # TODO: Adjust search range based on comparison\n        pass\n    \n    return -1  # Target not found\n\n# Test your implementation\nsorted_array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\ntarget = 7\nresult = binary_search(sorted_array, target)\nprint(f\"Target {target} found at index: {result}\")",
        "solutionCode": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1  # Target not found",
        "testCases": null,
        "hints": null,
        "prerequisites": null,
        "diamondReward": 45,
        "experienceReward": 90,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:42.252Z",
        "updatedAt": "2025-08-10T22:16:42.252Z",
        "examples": null,
        "learningObjectives": "[\"Understand logarithmic complexity\",\"Master binary search logic\",\"Learn efficient searching\",\"Practice divide-and-conquer\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Algorithm Viz\",\"Search\",\"Logarithmic\",\"Intermediate\"]"
      },
      {
        "id": "cme68u4j00004wc7o35pdp7g4",
        "title": "Big O Notation Master",
        "slug": "big-o-notation-master",
        "description": "Learn to analyze time and space complexity of algorithms and understand algorithmic efficiency",
        "content": "# Big O Notation\n\nBig O notation describes the performance characteristics of algorithms as input size grows.\n\n## Common Complexities:\n- **O(1)** - Constant time\n- **O(log n)** - Logarithmic time  \n- **O(n)** - Linear time\n- **O(n log n)** - Linearithmic time\n- **O(n²)** - Quadratic time\n- **O(2ⁿ)** - Exponential time\n\n## Why It Matters:\n- Predicts algorithm performance\n- Helps choose right algorithm\n- Critical for large datasets\n- Interview essential\n\nMaster this to write efficient code!",
        "difficulty": 4,
        "order": 5,
        "duration": 20,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Analyze Big O Complexity\n\n# Example 1: What's the time complexity?\ndef example_1(arr):\n    for i in range(len(arr)):\n        print(arr[i])\n    # Answer: O(?)\n\n# Example 2: What's the time complexity?\ndef example_2(arr):\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            print(arr[i], arr[j])\n    # Answer: O(?)\n\n# Example 3: What's the time complexity?\ndef example_3(arr):\n    if len(arr) == 0:\n        return\n    print(arr[0])\n    # Answer: O(?)\n\n# TODO: Implement a function that demonstrates O(n log n) complexity\ndef merge_sort_demo(arr):\n    # Hint: Divide array, recursively sort, then merge\n    pass",
        "solutionCode": "# Big O Analysis Solutions\n\n# Example 1: O(n) - Linear time\ndef example_1(arr):\n    for i in range(len(arr)):  # Loops n times\n        print(arr[i])\n    # Answer: O(n)\n\n# Example 2: O(n²) - Quadratic time  \ndef example_2(arr):\n    for i in range(len(arr)):      # Loops n times\n        for j in range(len(arr)):  # Nested loop, n times each\n            print(arr[i], arr[j])\n    # Answer: O(n²)\n\n# Example 3: O(1) - Constant time\ndef example_3(arr):\n    if len(arr) == 0:\n        return\n    print(arr[0])  # Single operation regardless of input size\n    # Answer: O(1)\n\n# O(n log n) demonstration\ndef merge_sort_demo(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort_demo(arr[:mid])    # Divides log n times\n    right = merge_sort_demo(arr[mid:])   # Each level processes n elements\n    \n    return merge(left, right)  # Total: O(n log n)",
        "testCases": null,
        "hints": null,
        "prerequisites": null,
        "diamondReward": 70,
        "experienceReward": 140,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:42.348Z",
        "updatedAt": "2025-08-10T22:16:42.348Z",
        "examples": null,
        "learningObjectives": "[\"Understand Big O notation\",\"Analyze algorithm complexity\",\"Compare algorithm efficiency\",\"Make informed algorithm choices\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Matching\",\"Big O\",\"Complexity Analysis\",\"Advanced\"]"
      },
      {
        "id": "cme68u4lu0005wc7o6ol204cg",
        "title": "Graph Traversal Explorer",
        "slug": "graph-traversal-explorer",
        "description": "Explore Depth-First Search (DFS) and Breadth-First Search (BFS) through interactive graph visualization",
        "content": "# Graph Traversal Algorithms\n\nGraph traversal is fundamental to many algorithms and applications.\n\n## Depth-First Search (DFS):\n- Explores as far as possible along each branch\n- Uses stack (or recursion)\n- Time: O(V + E), Space: O(V)\n\n## Breadth-First Search (BFS):\n- Explores neighbors before going deeper\n- Uses queue\n- Time: O(V + E), Space: O(V)\n- Finds shortest path in unweighted graphs\n\nPerfect for pathfinding, connectivity, and graph analysis!",
        "difficulty": 3,
        "order": 6,
        "duration": 30,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Implement Graph Traversal\nfrom collections import deque\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n    \n    def add_edge(self, u, v):\n        if u not in self.adjacency_list:\n            self.adjacency_list[u] = []\n        if v not in self.adjacency_list:\n            self.adjacency_list[v] = []\n        \n        self.adjacency_list[u].append(v)\n        self.adjacency_list[v].append(u)\n    \n    def dfs(self, start):\n        # TODO: Implement Depth-First Search\n        visited = set()\n        result = []\n        \n        def dfs_helper(node):\n            # TODO: Add DFS logic here\n            pass\n        \n        dfs_helper(start)\n        return result\n    \n    def bfs(self, start):\n        # TODO: Implement Breadth-First Search\n        visited = set()\n        queue = deque([start])\n        result = []\n        \n        while queue:\n            # TODO: Add BFS logic here\n            pass\n        \n        return result\n\n# Test your implementation\ng = Graph()\ng.add_edge(0, 1)\ng.add_edge(0, 2)\ng.add_edge(1, 3)\ng.add_edge(2, 4)\n\nprint(\"DFS:\", g.dfs(0))\nprint(\"BFS:\", g.bfs(0))",
        "solutionCode": "from collections import deque\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n    \n    def add_edge(self, u, v):\n        if u not in self.adjacency_list:\n            self.adjacency_list[u] = []\n        if v not in self.adjacency_list:\n            self.adjacency_list[v] = []\n        \n        self.adjacency_list[u].append(v)\n        self.adjacency_list[v].append(u)\n    \n    def dfs(self, start):\n        visited = set()\n        result = []\n        \n        def dfs_helper(node):\n            visited.add(node)\n            result.append(node)\n            \n            for neighbor in self.adjacency_list.get(node, []):\n                if neighbor not in visited:\n                    dfs_helper(neighbor)\n        \n        dfs_helper(start)\n        return result\n    \n    def bfs(self, start):\n        visited = set()\n        queue = deque([start])\n        result = []\n        visited.add(start)\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node)\n            \n            for neighbor in self.adjacency_list.get(node, []):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return result",
        "testCases": null,
        "hints": null,
        "prerequisites": null,
        "diamondReward": 65,
        "experienceReward": 130,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:42.450Z",
        "updatedAt": "2025-08-10T22:16:42.450Z",
        "examples": null,
        "learningObjectives": "[\"Understand graph representations\",\"Master DFS and BFS algorithms\",\"Learn queue and stack usage\",\"Apply traversal to real problems\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Algorithm Viz\",\"Graph\",\"DFS\",\"BFS\",\"Advanced\"]"
      },
      {
        "id": "cme68u4qj0006wc7o6bcw0vdz",
        "title": "Dynamic Programming Fundamentals",
        "slug": "dynamic-programming-fundamentals",
        "description": "Master the art of breaking complex problems into overlapping subproblems with memoization",
        "content": "# Dynamic Programming\n\nDynamic Programming solves complex problems by breaking them into simpler subproblems and storing results.\n\n## Key Concepts:\n1. **Optimal Substructure** - Optimal solution contains optimal solutions to subproblems\n2. **Overlapping Subproblems** - Same subproblems solved multiple times\n3. **Memoization** - Store solutions to avoid recomputation\n\n## Classic Example: Fibonacci\n- Naive: O(2ⁿ)\n- With DP: O(n)\n\nEssential for optimization problems!",
        "difficulty": 4,
        "order": 7,
        "duration": 25,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Dynamic Programming Examples\n\n# 1. Fibonacci with memoization\ndef fibonacci_memo(n, memo={}):\n    # TODO: Implement memoized fibonacci\n    # Base cases: fib(0) = 0, fib(1) = 1\n    # Use memo dictionary to store computed values\n    pass\n\n# 2. Climbing Stairs Problem\n# You can climb 1 or 2 steps at a time\n# How many ways to reach step n?\ndef climb_stairs(n):\n    # TODO: Use DP to solve climbing stairs\n    # Hint: dp[i] = dp[i-1] + dp[i-2]\n    pass\n\n# 3. Coin Change Problem\ndef coin_change(coins, amount):\n    # TODO: Find minimum coins needed to make amount\n    # Return -1 if impossible\n    pass\n\n# Test your implementations\nprint(\"Fibonacci(10):\", fibonacci_memo(10))\nprint(\"Climb stairs(5):\", climb_stairs(5))\nprint(\"Coin change([1,3,4], 6):\", coin_change([1,3,4], 6))",
        "solutionCode": "# Dynamic Programming Solutions\n\ndef fibonacci_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    \n    if n <= 1:\n        return n\n    \n    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)\n    return memo[n]\n\ndef climb_stairs(n):\n    if n <= 2:\n        return n\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]\n\ndef coin_change(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1",
        "testCases": null,
        "hints": null,
        "prerequisites": null,
        "diamondReward": 80,
        "experienceReward": 160,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:42.619Z",
        "updatedAt": "2025-08-10T22:16:42.619Z",
        "examples": null,
        "learningObjectives": "[\"Understand dynamic programming principles\",\"Master memoization techniques\",\"Solve optimization problems\",\"Identify overlapping subproblems\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Algorithm Viz\",\"Dynamic Programming\",\"Optimization\",\"Expert\"]"
      },
      {
        "id": "cme68u4td0007wc7ow0ia7vsk",
        "title": "Stack and Queue Fundamentals",
        "slug": "stack-queue-fundamentals",
        "description": "Master LIFO and FIFO data structures through interactive implementation and real-world applications",
        "content": "# Stack and Queue Data Structures\n\nFundamental linear data structures with different access patterns.\n\n## Stack (LIFO - Last In, First Out):\n- **Push**: Add to top\n- **Pop**: Remove from top\n- **Peek**: View top element\n- Applications: Function calls, undo operations, expression evaluation\n\n## Queue (FIFO - First In, First Out):\n- **Enqueue**: Add to rear\n- **Dequeue**: Remove from front\n- **Front**: View front element\n- Applications: Task scheduling, BFS, buffering\n\nBoth essential for algorithm implementation!",
        "difficulty": 2,
        "order": 8,
        "duration": 20,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Implement Stack and Queue\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        # TODO: Add item to top of stack\n        pass\n    \n    def pop(self):\n        # TODO: Remove and return top item\n        # Return None if empty\n        pass\n    \n    def peek(self):\n        # TODO: Return top item without removing\n        pass\n    \n    def is_empty(self):\n        # TODO: Check if stack is empty\n        pass\n    \n    def size(self):\n        # TODO: Return number of items\n        pass\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n    \n    def enqueue(self, item):\n        # TODO: Add item to rear\n        pass\n    \n    def dequeue(self):\n        # TODO: Remove and return front item\n        pass\n    \n    def front(self):\n        # TODO: Return front item without removing\n        pass\n    \n    def is_empty(self):\n        # TODO: Check if queue is empty\n        pass\n    \n    def size(self):\n        # TODO: Return number of items\n        pass\n\n# Test implementations\nstack = Stack()\nqueue = Queue()\n\n# Test stack\nstack.push(1)\nstack.push(2)\nprint(\"Stack pop:\", stack.pop())  # Should be 2\n\n# Test queue  \nqueue.enqueue(1)\nqueue.enqueue(2)\nprint(\"Queue dequeue:\", queue.dequeue())  # Should be 1",
        "solutionCode": "class Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        return None\n    \n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n        return None\n    \n    def is_empty(self):\n        return len(self.items) == 0\n    \n    def size(self):\n        return len(self.items)\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n    \n    def enqueue(self, item):\n        self.items.append(item)\n    \n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.pop(0)\n        return None\n    \n    def front(self):\n        if not self.is_empty():\n            return self.items[0]\n        return None\n    \n    def is_empty(self):\n        return len(self.items) == 0\n    \n    def size(self):\n        return len(self.items)",
        "testCases": null,
        "hints": null,
        "prerequisites": null,
        "diamondReward": 50,
        "experienceReward": 100,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:42.722Z",
        "updatedAt": "2025-08-10T22:16:42.722Z",
        "examples": null,
        "learningObjectives": "[\"Understand LIFO and FIFO principles\",\"Implement stack and queue operations\",\"Learn when to use each structure\",\"Practice object-oriented design\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Data Structures\",\"Stack\",\"Queue\",\"LIFO\",\"FIFO\",\"Intermediate\"]"
      },
      {
        "id": "cme68u4wb0008wc7o6uvoz3nx",
        "title": "Recursion Mastery Challenge",
        "slug": "recursion-mastery-challenge",
        "description": "Master recursive thinking through classic problems and learn to identify base cases and recursive relationships",
        "content": "# Recursion Fundamentals\n\nRecursion is a powerful programming technique where a function calls itself to solve smaller instances of the same problem.\n\n## Key Components:\n1. **Base Case** - Stopping condition\n2. **Recursive Case** - Function calls itself with modified input\n3. **Progress** - Each call moves toward base case\n\n## Classic Examples:\n- Factorial: n! = n * (n-1)!\n- Fibonacci: fib(n) = fib(n-1) + fib(n-2)\n- Tree traversal, Tower of Hanoi\n\nEssential for divide-and-conquer algorithms!",
        "difficulty": 3,
        "order": 9,
        "duration": 25,
        "category": "algorithms",
        "hasCodeExercise": true,
        "starterCode": "# Recursion Practice Problems\n\n# 1. Factorial\ndef factorial(n):\n    # TODO: Calculate n! recursively\n    # Base case: 0! = 1, 1! = 1\n    # Recursive case: n! = n * (n-1)!\n    pass\n\n# 2. Sum of digits\ndef sum_of_digits(n):\n    # TODO: Calculate sum of digits recursively\n    # Example: sum_of_digits(123) = 1 + 2 + 3 = 6\n    pass\n\n# 3. Power function\ndef power(base, exp):\n    # TODO: Calculate base^exp recursively\n    # Base case: base^0 = 1\n    # Recursive case: base^exp = base * base^(exp-1)\n    pass\n\n# 4. Palindrome check\ndef is_palindrome(s):\n    # TODO: Check if string is palindrome recursively\n    # Remove spaces and convert to lowercase\n    s = s.replace(\" \", \"\").lower()\n    # Base case: empty string or single char is palindrome\n    pass\n\n# Test your implementations\nprint(\"Factorial(5):\", factorial(5))        # Should be 120\nprint(\"Sum of digits(123):\", sum_of_digits(123))  # Should be 6\nprint(\"Power(2, 3):\", power(2, 3))          # Should be 8\nprint(\"Is 'racecar' palindrome?:\", is_palindrome(\"racecar\"))  # Should be True",
        "solutionCode": "def factorial(n):\n    # Base case\n    if n <= 1:\n        return 1\n    \n    # Recursive case\n    return n * factorial(n - 1)\n\ndef sum_of_digits(n):\n    # Base case\n    if n < 10:\n        return n\n    \n    # Recursive case: last digit + sum of remaining digits\n    return n % 10 + sum_of_digits(n // 10)\n\ndef power(base, exp):\n    # Base case\n    if exp == 0:\n        return 1\n    \n    # Recursive case\n    return base * power(base, exp - 1)\n\ndef is_palindrome(s):\n    # Clean the string\n    s = s.replace(\" \", \"\").lower()\n    \n    # Base case: empty or single character\n    if len(s) <= 1:\n        return True\n    \n    # Check first and last characters\n    if s[0] != s[-1]:\n        return False\n    \n    # Recursive case: check middle part\n    return is_palindrome(s[1:-1])",
        "testCases": null,
        "hints": null,
        "prerequisites": null,
        "diamondReward": 60,
        "experienceReward": 120,
        "isPublished": true,
        "createdAt": "2025-08-10T22:16:42.828Z",
        "updatedAt": "2025-08-10T22:16:42.828Z",
        "examples": null,
        "learningObjectives": "[\"Understand recursive thinking\",\"Identify base and recursive cases\",\"Solve problems with self-reference\",\"Avoid infinite recursion\"]",
        "resources": null,
        "sections": null,
        "tags": "[\"Algorithm Viz\",\"Recursion\",\"Problem Solving\",\"Advanced\"]"
      },
      {
        "id": "cme698aa30000wcj4sufpkwox",
        "title": "Python'a Giriş ve İlk Program",
        "slug": "python-giris-ilk-program",
        "description": "Python programlama diline giriş yapıyoruz ve ilk programımızı yazıyoruz.",
        "content": "# Python'a Giriş\n\nPython, öğrenmesi kolay ve güçlü bir programlama dilidir. Bu derste Python'ın temellerini öğreneceğiz.\n\n## Python Nedir?\n\nPython, 1991 yılında Guido van Rossum tarafından geliştirilmiş, yüksek seviyeli bir programlama dilidir.\n\n## İlk Programımız\n\nGeleneksel olarak, her programlama dilinde öğrendiğimiz ilk program \"Hello, World!\" programıdır.\n\n```python\nprint(\"Hello, World!\")\n```\n\nBu basit kod çalıştırıldığında ekrana \"Hello, World!\" yazısını yazdırır.\n\n## Neden Python?\n\n- Kolay öğrenilebilir syntax\n- Geniş kütüphane desteği\n- Çok amaçlı kullanım (web, veri analizi, yapay zeka)\n- Büyük topluluk desteği",
        "difficulty": 1,
        "order": 1,
        "duration": 45,
        "category": "python-basics",
        "hasCodeExercise": true,
        "starterCode": "# İlk Python programınızı yazın\n# \"Merhaba Dünya!\" yazdıran bir program oluşturun\n\n",
        "solutionCode": "# İlk Python programınızı yazın\n# \"Merhaba Dünya!\" yazdıran bir program oluşturun\n\nprint(\"Merhaba Dünya!\")",
        "testCases": "[{\"description\":\"Program 'Merhaba Dünya!' yazdırmalı\",\"expectedOutput\":\"Merhaba Dünya!\"}]",
        "hints": "Python'da ekrana yazı yazdırmak için print() fonksiyonunu kullanıyoruz.",
        "prerequisites": null,
        "diamondReward": 10,
        "experienceReward": 50,
        "isPublished": true,
        "createdAt": "2025-08-10T22:27:42.987Z",
        "updatedAt": "2025-08-10T22:27:42.987Z",
        "examples": null,
        "learningObjectives": null,
        "resources": null,
        "sections": null,
        "tags": null
      },
      {
        "id": "cme698at80001wcj4q1rge0fm",
        "title": "Değişkenler ve Veri Türleri",
        "slug": "degiskenler-veri-turleri",
        "description": "Python'da değişken tanımlama ve temel veri türlerini öğreniyoruz.",
        "content": "# Değişkenler ve Veri Türleri\n\nPython'da değişkenler, verileri saklamamızı sağlayan isimli konteynerlerdir.\n\n## Değişken Tanımlama\n\nPython'da değişken tanımlamak çok basittir:\n\n```python\nisim = \"Ahmet\"\nyas = 25\nboy = 1.75\nevli_mi = False\n```\n\n## Temel Veri Türleri\n\n### String (Metin)\n```python\nmesaj = \"Merhaba Python!\"\n```\n\n### Integer (Tam Sayı)\n```python\nsayi = 42\n```\n\n### Float (Ondalıklı Sayı)\n```python\npi = 3.14159\n```\n\n### Boolean (Mantıksal)\n```python\ndogru = True\nyanlis = False\n```\n\n## type() Fonksiyonu\n\nBir değişkenin türünü öğrenmek için:\n\n```python\nprint(type(isim))  # <class 'str'>\nprint(type(yas))   # <class 'int'>\n```",
        "difficulty": 1,
        "order": 2,
        "duration": 60,
        "category": "python-basics",
        "hasCodeExercise": true,
        "starterCode": "# Değişkenler oluşturun\n# 1. Adınızı string olarak\n# 2. Yaşınızı integer olarak\n# 3. Boyunuzu float olarak\n# 4. Öğrenci olup olmadığınızı boolean olarak\n\n",
        "solutionCode": "# Değişkenler oluşturun\nisim = \"Ali\"\nyas = 20\nboy = 1.70\nogrenci_mi = True\n\nprint(f\"İsim: {isim}\")\nprint(f\"Yaş: {yas}\")\nprint(f\"Boy: {boy}\")\nprint(f\"Öğrenci mi: {ogrenci_mi}\")",
        "testCases": "[{\"description\":\"4 farklı türde değişken tanımlanmalı\",\"variables\":[\"isim\",\"yas\",\"boy\",\"ogrenci_mi\"]}]",
        "hints": "Python'da değişken tanımlarken tür belirtmemize gerek yoktur. Python otomatik olarak türü belirler.",
        "prerequisites": null,
        "diamondReward": 15,
        "experienceReward": 75,
        "isPublished": true,
        "createdAt": "2025-08-10T22:27:43.676Z",
        "updatedAt": "2025-08-10T22:27:43.676Z",
        "examples": null,
        "learningObjectives": null,
        "resources": null,
        "sections": null,
        "tags": null
      },
      {
        "id": "cme698b6d0002wcj44p4qnt8w",
        "title": "Koşullu İfadeler (if-elif-else)",
        "slug": "kosullu-ifadeler",
        "description": "Python'da karar verme yapıları olan if, elif ve else ifadelerini öğreniyoruz.",
        "content": "# Koşullu İfadeler\n\nProgramlarda farklı durumlara göre farklı işlemler yapmamız gerekir. Bu durumda koşullu ifadeleri kullanırız.\n\n## if İfadesi\n\n```python\nyas = 18\n\nif yas >= 18:\n    print(\"Ehliyet alabilirsiniz\")\n```\n\n## if-else İfadesi\n\n```python\nyas = 16\n\nif yas >= 18:\n    print(\"Ehliyet alabilirsiniz\")\nelse:\n    print(\"Ehliyet alamazsınız\")\n```\n\n## if-elif-else İfadesi\n\n```python\nnot_ortalamasi = 85\n\nif not_ortalamasi >= 90:\n    print(\"Pekiyi\")\nelif not_ortalamasi >= 80:\n    print(\"İyi\")\nelif not_ortalamasi >= 70:\n    print(\"Orta\")\nelse:\n    print(\"Geçer\")\n```\n\n## Karşılaştırma Operatörleri\n\n- `==` : Eşit mi?\n- `!=` : Eşit değil mi?\n- `>` : Büyük mü?\n- `<` : Küçük mü?\n- `>=` : Büyük eşit mi?\n- `<=` : Küçük eşit mi?\n\n## Mantıksal Operatörler\n\n- `and` : Ve\n- `or` : Veya\n- `not` : Değil",
        "difficulty": 2,
        "order": 3,
        "duration": 75,
        "category": "control-flow",
        "hasCodeExercise": true,
        "starterCode": "# Bir sayının pozitif, negatif veya sıfır olduğunu kontrol eden program yazın\nsayi = int(input(\"Bir sayı girin: \"))\n\n# Kodunuzu buraya yazın\n\n",
        "solutionCode": "# Bir sayının pozitif, negatif veya sıfır olduğunu kontrol eden program yazın\nsayi = int(input(\"Bir sayı girin: \"))\n\nif sayi > 0:\n    print(\"Sayı pozitif\")\nelif sayi < 0:\n    print(\"Sayı negatif\")\nelse:\n    print(\"Sayı sıfır\")",
        "testCases": "[{\"input\":\"5\",\"expectedOutput\":\"Sayı pozitif\"},{\"input\":\"-3\",\"expectedOutput\":\"Sayı negatif\"},{\"input\":\"0\",\"expectedOutput\":\"Sayı sıfır\"}]",
        "hints": "Önce pozitif kontrolü yapın, sonra negatif kontrolü yapın. Kalan durum sıfır olacaktır.",
        "prerequisites": null,
        "diamondReward": 20,
        "experienceReward": 100,
        "isPublished": true,
        "createdAt": "2025-08-10T22:27:44.150Z",
        "updatedAt": "2025-08-10T22:27:44.150Z",
        "examples": null,
        "learningObjectives": null,
        "resources": null,
        "sections": null,
        "tags": null
      },
      {
        "id": "cme698bli0003wcj4rp84ioco",
        "title": "Döngüler - for ve while",
        "slug": "donguler-for-while",
        "description": "Python'da tekrar yapıları olan for ve while döngülerini öğreniyoruz.",
        "content": "# Döngüler\n\nDöngüler, aynı kod bloğunu birden fazla kez çalıştırmamızı sağlar.\n\n## for Döngüsü\n\n### Sayı aralığında döngü\n```python\nfor i in range(5):\n    print(i)  # 0, 1, 2, 3, 4\n```\n\n### Liste üzerinde döngü\n```python\nmeyveler = [\"elma\", \"armut\", \"muz\"]\nfor meyve in meyveler:\n    print(meyve)\n```\n\n### String üzerinde döngü\n```python\nkelime = \"Python\"\nfor harf in kelime:\n    print(harf)\n```\n\n## while Döngüsü\n\n```python\nsayac = 0\nwhile sayac < 5:\n    print(sayac)\n    sayac += 1\n```\n\n## range() Fonksiyonu\n\n```python\nrange(5)        # 0, 1, 2, 3, 4\nrange(1, 6)     # 1, 2, 3, 4, 5\nrange(0, 10, 2) # 0, 2, 4, 6, 8\n```\n\n## break ve continue\n\n### break - Döngüden çık\n```python\nfor i in range(10):\n    if i == 5:\n        break\n    print(i)  # 0, 1, 2, 3, 4\n```\n\n### continue - Bir sonraki iterasyona geç\n```python\nfor i in range(5):\n    if i == 2:\n        continue\n    print(i)  # 0, 1, 3, 4\n```",
        "difficulty": 2,
        "order": 4,
        "duration": 90,
        "category": "control-flow",
        "hasCodeExercise": true,
        "starterCode": "# 1'den 100'e kadar olan sayıların toplamını hesaplayan program yazın\n# for döngüsü kullanın\n\ntoplam = 0\n# Kodunuzu buraya yazın\n\nprint(f\"1'den 100'e kadar olan sayıların toplamı: {toplam}\")",
        "solutionCode": "# 1'den 100'e kadar olan sayıların toplamını hesaplayan program yazın\n# for döngüsü kullanın\n\ntoplam = 0\nfor i in range(1, 101):\n    toplam += i\n\nprint(f\"1'den 100'e kadar olan sayıların toplamı: {toplam}\")",
        "testCases": "[{\"description\":\"1'den 100'e kadar olan sayıların toplamı 5050 olmalı\",\"expectedResult\":5050}]",
        "hints": "range(1, 101) kullanarak 1'den 100'e kadar (100 dahil) sayıları alabilirsiniz.",
        "prerequisites": null,
        "diamondReward": 25,
        "experienceReward": 125,
        "isPublished": true,
        "createdAt": "2025-08-10T22:27:44.694Z",
        "updatedAt": "2025-08-10T22:27:44.694Z",
        "examples": null,
        "learningObjectives": null,
        "resources": null,
        "sections": null,
        "tags": null
      },
      {
        "id": "cme698bxe0004wcj4vq18q3d1",
        "title": "Fonksiyonlar",
        "slug": "fonksiyonlar",
        "description": "Python'da fonksiyon tanımlama, parametre kullanma ve değer döndürme işlemlerini öğreniyoruz.",
        "content": "# Fonksiyonlar\n\nFonksiyonlar, belirli bir görevi yerine getiren, yeniden kullanılabilir kod bloklarıdır.\n\n## Basit Fonksiyon\n\n```python\ndef selamla():\n    print(\"Merhaba!\")\n\nselamla()  # Fonksiyonu çağır\n```\n\n## Parametreli Fonksiyon\n\n```python\ndef selamla(isim):\n    print(f\"Merhaba {isim}!\")\n\nselamla(\"Ali\")\n```\n\n## Varsayılan Parametre\n\n```python\ndef selamla(isim=\"Dünya\"):\n    print(f\"Merhaba {isim}!\")\n\nselamla()        # Merhaba Dünya!\nselamla(\"Ali\")   # Merhaba Ali!\n```\n\n## Değer Döndüren Fonksiyon\n\n```python\ndef topla(a, b):\n    return a + b\n\nsonuc = topla(5, 3)\nprint(sonuc)  # 8\n```\n\n## Çoklu Değer Döndürme\n\n```python\ndef hesapla(a, b):\n    toplam = a + b\n    carpim = a * b\n    return toplam, carpim\n\nt, c = hesapla(5, 3)\nprint(t, c)  # 8 15\n```\n\n## Lambda Fonksiyonları\n\n```python\nkare = lambda x: x ** 2\nprint(kare(5))  # 25\n```\n\n## Docstring\n\n```python\ndef topla(a, b):\n    \"\"\"\n    İki sayının toplamını hesaplar.\n    \n    Args:\n        a (int): İlk sayı\n        b (int): İkinci sayı\n    \n    Returns:\n        int: İki sayının toplamı\n    \"\"\"\n    return a + b\n```",
        "difficulty": 3,
        "order": 5,
        "duration": 120,
        "category": "functions",
        "hasCodeExercise": true,
        "starterCode": "# Bir sayının faktöriyelini hesaplayan fonksiyon yazın\n# Örnek: faktoriyel(5) = 5 * 4 * 3 * 2 * 1 = 120\n\ndef faktoriyel(n):\n    # Kodunuzu buraya yazın\n    pass\n\n# Test\nprint(faktoriyel(5))  # 120 olmalı",
        "solutionCode": "# Bir sayının faktöriyelini hesaplayan fonksiyon yazın\n# Örnek: faktoriyel(5) = 5 * 4 * 3 * 2 * 1 = 120\n\ndef faktoriyel(n):\n    if n <= 1:\n        return 1\n    else:\n        return n * faktoriyel(n - 1)\n\n# Test\nprint(faktoriyel(5))  # 120 olmalı",
        "testCases": "[{\"input\":5,\"expectedOutput\":120},{\"input\":3,\"expectedOutput\":6},{\"input\":0,\"expectedOutput\":1}]",
        "hints": "Faktöriyel hesaplamak için recursive (özyinelemeli) fonksiyon kullanabilirsiniz.",
        "prerequisites": null,
        "diamondReward": 30,
        "experienceReward": 150,
        "isPublished": true,
        "createdAt": "2025-08-10T22:27:45.122Z",
        "updatedAt": "2025-08-10T22:27:45.122Z",
        "examples": null,
        "learningObjectives": null,
        "resources": null,
        "sections": null,
        "tags": null
      },
      {
        "id": "cme698caq0005wcj4piqrdr06",
        "title": "Listeler ve Liste İşlemleri",
        "slug": "listeler-liste-islemleri",
        "description": "Python'da en önemli veri yapılarından biri olan listeleri ve liste işlemlerini öğreniyoruz.",
        "content": "# Listeler\n\nListeler, Python'da birden fazla öğeyi saklamamızı sağlayan veri yapılarıdır.\n\n## Liste Oluşturma\n\n```python\n# Boş liste\nliste = []\n\n# Sayılarla liste\nsayilar = [1, 2, 3, 4, 5]\n\n# Karışık türlerle liste\nkarisik = [1, \"merhaba\", 3.14, True]\n```\n\n## Liste Elemanlarına Erişim\n\n```python\nmeyveler = [\"elma\", \"armut\", \"muz\"]\n\nprint(meyveler[0])   # elma (ilk eleman)\nprint(meyveler[-1])  # muz (son eleman)\nprint(meyveler[1:3]) # ['armut', 'muz'] (dilim)\n```\n\n## Liste Metodları\n\n```python\nliste = [1, 2, 3]\n\n# Eleman ekleme\nliste.append(4)        # [1, 2, 3, 4]\nliste.insert(0, 0)     # [0, 1, 2, 3, 4]\n\n# Eleman çıkarma\nliste.remove(2)        # [0, 1, 3, 4]\nson_eleman = liste.pop() # [0, 1, 3], son_eleman = 4\n\n# Diğer işlemler\nprint(len(liste))      # Liste uzunluğu\nprint(max(liste))      # En büyük eleman\nprint(min(liste))      # En küçük eleman\nprint(sum(liste))      # Elemanların toplamı\n```\n\n## Liste Comprehension\n\n```python\n# Normal yöntem\nkareler = []\nfor i in range(10):\n    kareler.append(i ** 2)\n\n# Liste comprehension\nkareler = [i ** 2 for i in range(10)]\n\n# Koşullu liste comprehension\ncift_kareler = [i ** 2 for i in range(10) if i % 2 == 0]\n```",
        "difficulty": 2,
        "order": 6,
        "duration": 100,
        "category": "data-structures",
        "hasCodeExercise": true,
        "starterCode": "# Bir listede en büyük ve en küçük elemanı bulan fonksiyon yazın\ndef min_max_bul(liste):\n    # Kodunuzu buraya yazın\n    # En küçük ve en büyük değeri tuple olarak döndürün\n    pass\n\n# Test\nsayilar = [3, 7, 2, 9, 1, 5]\nminimum, maksimum = min_max_bul(sayilar)\nprint(f\"En küçük: {minimum}, En büyük: {maksimum}\")",
        "solutionCode": "# Bir listede en büyük ve en küçük elemanı bulan fonksiyon yazın\ndef min_max_bul(liste):\n    if not liste:  # Boş liste kontrolü\n        return None, None\n    \n    minimum = liste[0]\n    maksimum = liste[0]\n    \n    for sayi in liste:\n        if sayi < minimum:\n            minimum = sayi\n        if sayi > maksimum:\n            maksimum = sayi\n    \n    return minimum, maksimum\n\n# Test\nsayilar = [3, 7, 2, 9, 1, 5]\nminimum, maksimum = min_max_bul(sayilar)\nprint(f\"En küçük: {minimum}, En büyük: {maksimum}\")",
        "testCases": "[{\"input\":[3,7,2,9,1,5],\"expected\":[1,9]},{\"input\":[10],\"expected\":[10,10]}]",
        "hints": "Liste boş olma durumunu da kontrol etmeyi unutmayın.",
        "prerequisites": null,
        "diamondReward": 25,
        "experienceReward": 125,
        "isPublished": true,
        "createdAt": "2025-08-10T22:27:45.603Z",
        "updatedAt": "2025-08-10T22:27:45.603Z",
        "examples": null,
        "learningObjectives": null,
        "resources": null,
        "sections": null,
        "tags": null
      },
      {
        "id": "cme698chv0006wcj488ex5ha3",
        "title": "Sözlükler (Dictionaries) - İleri Seviye",
        "slug": "sozlukler-ileri-seviye",
        "description": "Python sözlüklerinin ileri seviye kullanımını ve nested dictionary yapılarını öğreniyoruz.",
        "content": "# Sözlükler - İleri Seviye\n\nBu derste Python sözlüklerinin daha karmaşık kullanım alanlarını göreceğiz.\n\n## Nested Dictionaries\n\n```python\nogrenciler = {\n    \"123\": {\n        \"isim\": \"Ali\",\n        \"yas\": 20,\n        \"notlar\": {\"matematik\": 85, \"fizik\": 92}\n    },\n    \"124\": {\n        \"isim\": \"Ayşe\", \n        \"yas\": 19,\n        \"notlar\": {\"matematik\": 95, \"fizik\": 87}\n    }\n}\n```\n\nBu ders henüz tamamlanmamıştır ve draft modundadır.",
        "difficulty": 4,
        "order": 7,
        "duration": 150,
        "category": "data-structures",
        "hasCodeExercise": false,
        "starterCode": null,
        "solutionCode": null,
        "testCases": null,
        "hints": null,
        "prerequisites": null,
        "diamondReward": 35,
        "experienceReward": 175,
        "isPublished": false,
        "createdAt": "2025-08-10T22:27:45.860Z",
        "updatedAt": "2025-08-10T22:27:45.860Z",
        "examples": null,
        "learningObjectives": null,
        "resources": null,
        "sections": null,
        "tags": null
      }
    ],
    "codeArenaProgress": [],
    "codeSubmissions": []
  }
}